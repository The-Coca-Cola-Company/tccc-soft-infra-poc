<policies>
    <inbound>
        <!-- Validate subscription key -->
        <validate-header header-name="Ocp-Apim-Subscription-Key" failed-check-httpcode="401" failed-check-error-message="Access denied - invalid subscription key">
            <value>@(context.Subscription.Key)</value>
        </validate-header>
        
        <!-- Extract bottler identity from subscription -->
        <set-variable name="bottlerId" value="@(context.Subscription.Name)" />
        
        <!-- Rate limiting per bottler -->
        <rate-limit-by-key calls="100" renewal-period="60" counter-key="@(context.Variables.GetValueOrDefault<string>("bottlerId"))" />
        
        <!-- MCP-specific rate limiting for intensive operations -->
        <choose>
            <when condition="@(context.Request.Url.Path.StartsWith("/api/mcp/"))">
                <rate-limit-by-key calls="50" renewal-period="60" counter-key="@(context.Variables.GetValueOrDefault<string>("bottlerId") + "-mcp")" />
            </when>
            <when condition="@(context.Request.Url.Path.StartsWith("/api/query/natural"))">
                <rate-limit-by-key calls="20" renewal-period="60" counter-key="@(context.Variables.GetValueOrDefault<string>("bottlerId") + "-natural")" />
            </when>
        </choose>
        
        <!-- Quota per bottler -->
        <quota-by-key calls="10000" renewal-period="86400" counter-key="@(context.Variables.GetValueOrDefault<string>("bottlerId"))" />
        
        <!-- MCP tool execution quota -->
        <choose>
            <when condition="@(context.Request.Url.Path == "/api/mcp/tools/execute")">
                <quota-by-key calls="1000" renewal-period="86400" counter-key="@(context.Variables.GetValueOrDefault<string>("bottlerId") + "-mcp-execute")" />
            </when>
        </choose>
        
        <!-- Add bottler identity headers -->
        <set-header name="X-Bottler-ID" exists-action="override">
            <value>@(context.Variables.GetValueOrDefault<string>("bottlerId"))</value>
        </set-header>
        
        <!-- Add request tracking headers -->
        <set-header name="X-Request-ID" exists-action="override">
            <value>@(context.RequestId)</value>
        </set-header>
        
        <!-- Add MCP context headers -->
        <choose>
            <when condition="@(context.Request.Url.Path.StartsWith("/api/mcp/"))">
                <set-header name="X-MCP-Request" exists-action="override">
                    <value>true</value>
                </set-header>
                <set-header name="X-MCP-Bottler-Context" exists-action="override">
                    <value>@(context.Variables.GetValueOrDefault<string>("bottlerId"))</value>
                </set-header>
            </when>
        </choose>
        
        <!-- Log request -->
        <log-to-eventhub logger-id="bottler-requests">
            @{
                return new JObject(
                    new JProperty("EventTime", DateTime.UtcNow.ToString()),
                    new JProperty("BottlerId", context.Variables.GetValueOrDefault<string>("bottlerId")),
                    new JProperty("OperationName", context.Operation.Name),
                    new JProperty("RequestId", context.RequestId),
                    new JProperty("IpAddress", context.Request.IpAddress),
                    new JProperty("Path", context.Request.Url.Path),
                    new JProperty("IsMCPRequest", context.Request.Url.Path.StartsWith("/api/mcp/"))
                ).ToString();
            }
        </log-to-eventhub>
        
        <!-- Validate hub-spoke pattern -->
        <choose>
            <when condition="@(context.Request.Headers.GetValueOrDefault("X-Target-Bottler","") != "" && context.Request.Headers.GetValueOrDefault("X-Target-Bottler","") != context.Variables.GetValueOrDefault<string>("bottlerId"))">
                <return-response>
                    <set-status code="403" reason="Forbidden" />
                    <set-body>{"error": "Hub-Spoke violation: Direct bottler-to-bottler communication is not allowed"}</set-body>
                </return-response>
            </when>
        </choose>
        
        <!-- Add security headers -->
        <set-header name="X-Content-Type-Options" exists-action="override">
            <value>nosniff</value>
        </set-header>
        <set-header name="X-Frame-Options" exists-action="override">
            <value>DENY</value>
        </set-header>
        <set-header name="X-XSS-Protection" exists-action="override">
            <value>1; mode=block</value>
        </set-header>
        
        <!-- Cache lookup for read operations -->
        <cache-lookup vary-by-developer="false" vary-by-developer-groups="false" downstream-caching-type="none">
            <vary-by-header>X-Bottler-ID</vary-by-header>
            <vary-by-query-parameter>*</vary-by-query-parameter>
        </cache-lookup>
        
        <!-- Request size limit for MCP operations -->
        <choose>
            <when condition="@(context.Request.Url.Path.StartsWith("/api/mcp/tools/execute"))">
                <set-body>@{
                    var body = context.Request.Body.As<JObject>(preserveContent: true);
                    if (body != null && body.ToString().Length > 1048576) // 1MB limit
                    {
                        return new JObject(
                            new JProperty("error", "Request body too large for MCP tool execution"),
                            new JProperty("maxSize", "1MB")
                        ).ToString();
                    }
                    return body.ToString();
                }</set-body>
            </when>
        </choose>
    </inbound>
    
    <backend>
        <!-- Forward to backend Function App -->
        <forward-request timeout="30" />
        
        <!-- Extended timeout for MCP operations -->
        <choose>
            <when condition="@(context.Request.Url.Path.StartsWith("/api/mcp/tools/execute"))">
                <forward-request timeout="60" />
            </when>
            <when condition="@(context.Request.Url.Path == "/api/query/natural")">
                <forward-request timeout="120" />
            </when>
        </choose>
    </backend>
    
    <outbound>
        <!-- Cache store for read operations -->
        <cache-store duration="300" />
        
        <!-- Extended cache for MCP tool listings -->
        <choose>
            <when condition="@(context.Request.Url.Path == "/api/mcp/tools/list")">
                <cache-store duration="600" />
            </when>
            <when condition="@(context.Request.Url.Path == "/api/mcp/servers/list")">
                <cache-store duration="900" />
            </when>
        </choose>
        
        <!-- Remove internal headers -->
        <set-header name="X-AspNet-Version" exists-action="delete" />
        <set-header name="X-Powered-By" exists-action="delete" />
        <set-header name="X-MCP-Internal-Server" exists-action="delete" />
        
        <!-- Add response headers -->
        <set-header name="X-Response-Time" exists-action="override">
            <value>@(DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss"))</value>
        </set-header>
        <set-header name="X-Request-Duration-Ms" exists-action="override">
            <value>@(context.Elapsed.TotalMilliseconds.ToString())</value>
        </set-header>
        
        <!-- Add MCP integration version -->
        <choose>
            <when condition="@(context.Request.Url.Path.StartsWith("/api/mcp/"))">
                <set-header name="X-MCP-Version" exists-action="override">
                    <value>2.0.0</value>
                </set-header>
            </when>
        </choose>
        
        <!-- Log response -->
        <log-to-eventhub logger-id="bottler-responses">
            @{
                return new JObject(
                    new JProperty("EventTime", DateTime.UtcNow.ToString()),
                    new JProperty("BottlerId", context.Variables.GetValueOrDefault<string>("bottlerId")),
                    new JProperty("RequestId", context.RequestId),
                    new JProperty("ResponseCode", context.Response.StatusCode),
                    new JProperty("Duration", context.Elapsed.TotalMilliseconds),
                    new JProperty("Path", context.Request.Url.Path),
                    new JProperty("IsMCPRequest", context.Request.Url.Path.StartsWith("/api/mcp/"))
                ).ToString();
            }
        </log-to-eventhub>
        
        <!-- Performance warning for slow MCP operations -->
        <choose>
            <when condition="@(context.Request.Url.Path.StartsWith("/api/mcp/") && context.Elapsed.TotalMilliseconds > 5000)">
                <set-header name="X-Performance-Warning" exists-action="override">
                    <value>MCP operation took longer than expected</value>
                </set-header>
            </when>
        </choose>
    </outbound>
    
    <on-error>
        <!-- Log errors -->
        <log-to-eventhub logger-id="bottler-errors">
            @{
                return new JObject(
                    new JProperty("EventTime", DateTime.UtcNow.ToString()),
                    new JProperty("BottlerId", context.Variables.GetValueOrDefault<string>("bottlerId", "unknown")),
                    new JProperty("RequestId", context.RequestId),
                    new JProperty("Source", context.LastError.Source),
                    new JProperty("Reason", context.LastError.Reason),
                    new JProperty("Message", context.LastError.Message),
                    new JProperty("Path", context.Request?.Url?.Path ?? "unknown"),
                    new JProperty("IsMCPError", context.Request?.Url?.Path?.StartsWith("/api/mcp/") ?? false)
                ).ToString();
            }
        </log-to-eventhub>
        
        <!-- Return sanitized error -->
        <choose>
            <when condition="@(context.LastError.Source == "rate-limit-by-key")">
                <return-response>
                    <set-status code="429" reason="Too Many Requests" />
                    <set-header name="Retry-After" exists-action="override">
                        <value>60</value>
                    </set-header>
                    <set-body>{"error": "Rate limit exceeded. Please retry after 60 seconds.", "requestId": "@(context.RequestId)"}</set-body>
                </return-response>
            </when>
            <when condition="@(context.LastError.Source == "quota-by-key")">
                <return-response>
                    <set-status code="429" reason="Quota Exceeded" />
                    <set-header name="Retry-After" exists-action="override">
                        <value>86400</value>
                    </set-header>
                    <set-body>{"error": "Daily quota exceeded. Please retry tomorrow.", "requestId": "@(context.RequestId)"}</set-body>
                </return-response>
            </when>
            <otherwise>
                <return-response>
                    <set-status code="500" reason="Internal Server Error" />
                    <set-body>{"error": "An error occurred processing your request", "requestId": "@(context.RequestId)"}</set-body>
                </return-response>
            </otherwise>
        </choose>
    </on-error>
</policies>